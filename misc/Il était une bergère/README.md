# Challenge Name: Il était une bergère

---

## Statement

Note: This challenge uses files shared by several challenges. You can find more informations here: https://fcsc.fr/vm

Il était une bergère,  
et ron, ron, ron petit patapon;  
il était une bergère  
qui rangeait ses moutons,  
ron, ron,  
qui rangeait ses moutons.

Elle voulait un carré,  
et ron, ron, ron petit patapon;  
Elle voulait un carré,  
avec ses moutons,  
ron, ron  
avec ses moutons.

(These are lyrics of a famous French song for kids)

`nc chall.fcsc.fr 2051`  
Files: `machine.py`, `assembly.py`

---

## Solution


**Challenge:** Implement an integer square-root routine on a custom VM to retrieve the flag from `il-etait-une-bergere.py`.

The provided files include:

- `assembly.py`: Assembler for the VM instruction set.
- `machine.py`: VM implementation tracking registers, flags, and a floating-point accelerator.
- `il-etait-une-bergere.py`: Driver script that loads your bytecode, tests it on a large constant and random inputs, and then prints the flag on success.

## Understanding the VM

- **Registers**: R0–R15, plus special registers (`RB` holds exponent input `e`).
- **Instruction format**: 4‑hex-digit opcodes, decoded by `assembly.py` and `machine.py`.
- **Key operations**: integer division (`DIV`), bit-length (`BTL`), shifts (`SLL`, `SRL`), compare (`CMP`), conditional jumps (`JNCR`, `JR`, etc.).

### Testing environment

The driver does:

1. **Correctness test** on `e = 2^4095`.
2. **Random tests** on 32 samples of size `< 2^4096`.
3. On **success**, prints `FCSC{…}` from `flag.txt`.

Failing any test or a runtime error will abort execution.

## Strategy: Newton’s Method for √

To compute `⌊√e⌋`, we used the iteration:

```
x₀ = 1 << ceil(bitlen(e)/2)
while True:
    tmp = e // x
    new = (x + tmp) >> 1
    if new >= x:
        return x
    x = new
```

This converges in O(log e) steps, each step requiring one division, a few additions/shifts, and a compare+branch.

## Assembly Implementation

```asm
; Initialize
MOV   R1, RB        ; R1 := e
MOV   R6, #1        ; R6 := 1
MOV   R5, #1        ; R5 := 1 for shifts

; Compute initial x₀ = 1 << ceil(bitlen(e)/2)
BTL   R4, R1        ; R4 := bitlen(e)
ADD   R4, R4, R6    ; R4 := bitlen(e) + 1
SRL   R4, R4, R5    ; R4 := ceil(bitlen/2)
SLL   R2, R6, R4    ; R2 := 1 << R4

loop:
    MOV   R4, R1    ; tmp := e
    DIV   R4, R4, R2; tmp := e // x
    ADD   R4, R2, R4; sum := x + tmp
    SRL   R3, R4, R5; new := sum >> 1
    CMP   R3, R2    ; compare new vs x
    JNCR  update    ; if new < x, update and loop
    MOV   R0, R2    ; else result := x
    STP             ; stop

update:
    MOV   R2, R3    ; x := new
    JR    loop      ; repeat
```

### Assembled Bytecode

Using `assembly.py`:

```
00B1800600018005000101144BA449644732001450A44B1449630623CD02002014000032CFF6
```

## Automating Bytecode Generation

We bundled the assembly into a Python helper `make_sqrt_code.py`:

```python
from assembly import assembly

asm = [ ... ]  # as above
def main(): print(assembly(asm).upper())
if __name__=="__main__": main()
```

Running this script yields the exact hex string to paste.

## Retrieving the Flag

1. Run the driver:
   ```bash
   python il-etait-une-bergere.py
   ```
2. Paste the generated bytecode.
3. On success, the script prints:
   ```
   [+] Correct, congrats! Here is the flag:
   FCSC{…}
   ```
4. Once it succeed, we use the same generated bytecode but this time with server : nc chall.fcsc.fr 2051

```bash
(my_env) salaheddinealabouch@Salah-Eddines-MacBook-Pro fcsc_2025_writeups % nc chall.fcsc.fr 2051
Enter your bytecode in hexadecimal:
>>> 00B1800600018005000101144BA449644732001450A44B1449630623CD02002014000032CFF6
[+] Testing correctness...
[+] Correct, congrats! Congrats! Here is the flag:
FCSC{bdd5a8bcb20359f69f3999ba12c90e026c0961e441d0c6f1e23c952d51abc2b4}
```


---

## Flag

```
FCSC{bdd5a8bcb20359f69f3999ba12c90e026c0961e441d0c6f1e23c952d51abc2b4}
```